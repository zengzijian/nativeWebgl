<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html><html lang="en">
<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="lib0/webgl-utils.js"></script>
    <script src="lib0/webgl-debug.js"></script>
    <script src="lib0/cuon-utils.js"></script>
    <script src="lib0/cuon-matrix.js"></script>
</head>
<body>
<canvas id="webgl" ></canvas>
<script>
    var vertex_shader_source =
        'attribute vec4 a_Position;'+
        'attribute vec4 a_Color;'+
        'varying vec4 v_Color;'+
        'uniform mat4 u_ModelMatrix;'+
        'uniform mat4 u_MvpMatrix;'+ // 合并投影、视图、模型矩阵，减少在着色器中的矩阵运算量
        'varying float v_Dist;'+
        'uniform vec4 u_Eye;'+
        'void main() {'+
        ' gl_Position = u_MvpMatrix * a_Position;'+
        ' v_Color = a_Color;'+
        // ' v_Dist = distance(u_ModelMatrix * a_Position, u_Eye);'+
        ' v_Dist = gl_Position.w;'+ // 【使用gl_Position的w分量，来近似计算出顶点与视点的距离！！！】
        '}';

    // 在片元着色器中，添加了varying或者attribute变量，需要精度限定词！！！
    var fragment_shader_source =
        'precision mediump float;'+
        'varying vec4 v_Color;'+
        'uniform vec3 u_FogColor;'+
        'uniform vec2 u_FogDist;'+
        'varying float v_Dist;'+
        'void main() {'+
        ' float fogFactor = clamp((u_FogDist.y - v_Dist)/(u_FogDist.y - u_FogDist.x), 0.0, 1.0);'+
        // ' vec3 color = (vec3(v_Color) * fogFactor) + (u_FogColor * (1.0 - fogFactor));'+
        ' vec3 color = mix(u_FogColor, vec3(v_Color), fogFactor);'+ // glsl自带的mix进行线性混合 mix(x,y,a) = x*(1-a)+y*a
        ' gl_FragColor = vec4(color, v_Color.a);'+
        '}';

    var canvas = document.getElementById("webgl");
    canvas.width = 400;
    canvas.height = 400;

    var gl = canvas.getContext("webgl", {
        antialias: true
    });

    initShaders(gl, vertex_shader_source, fragment_shader_source);

    var n = initVertexBuffer();

    var fogColor = new Float32Array([0.137, 0.231, 0.423]);
    var fogDist = new Float32Array([55, 80]);
    var eye = new Float32Array([25, 65, 35, 1.0]);

    var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');
    var u_ModelMatrix = gl.getUniformLocation(gl.program, 'u_ModelMatrix');
    var u_Eye = gl.getUniformLocation(gl.program, 'u_Eye');
    var u_FogColor = gl.getUniformLocation(gl.program, 'u_FogColor');
    var u_FogDist = gl.getUniformLocation(gl.program, 'u_FogDist');

    gl.uniform3fv(u_FogColor, fogColor);
    gl.uniform2fv(u_FogDist, fogDist);
    gl.uniform4fv(u_Eye, eye);

    var modelMatrix = new Matrix4();
    modelMatrix.setScale(10, 10, 10);
    gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements);

    var mvpMatrix = new Matrix4();
    mvpMatrix.setPerspective(30, canvas.width / canvas.height, 1, 1000);
    mvpMatrix.lookAt(eye[0], eye[1], eye[2], 0, 0, 0, 0, 1, 0);
    mvpMatrix.multiply(modelMatrix); // vp矩阵右乘model矩阵，构成mvp矩阵
    gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);

    // var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');
    // var mvpMatrix = new Matrix4();
    // // <proj> x <view>
    // // 将mvpMatrix先设置成投影矩阵，再右乘一个视图矩阵，有两种方法
    // // 1.mvpMatrix.lookAt();
    // // 2.mvpMatrix.multiply(viewMatrix);
    // mvpMatrix.setPerspective(30, canvas.width / canvas.height, 1, 100);
    // mvpMatrix.lookAt(3, 3, 9, 0, 0, 0, 0, 1, 0);
    // gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);

    gl.clearColor(fogColor[0], fogColor[1], fogColor[2], 1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

    // gl.drawArrays(gl.TRIANGLES, 0, n);
    // gl.drawElements(gl.LINE_STRIP, n, gl.UNSIGNED_BYTE, 0);
    gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);

    function initEventHandle() {
        document.onkeydown = function(e) {
            switch(e.keyCode) {
                case 38: //up方向键
                    fogDist[1] += 1;
                    break;
                case 40: //down方向键
                    if(fogDist[0] < fogDist[1]) {
                        fogDist[1] -= 1;
                    }
                    break;
            }
            gl.uniform2fv(u_FogDist, fogDist);
            gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
            gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
        }
    }

    initEventHandle();

    function initVertexBuffer() {

        var vertices = new Float32Array([
            // 将顶点坐标和颜色rgb值放在同一个数组中，即共用一个缓冲区对象
            // 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, // v0 White
            // -1.0, 1.0, 1.0, 1.0, 0.0, 1.0, // v1 Magenta
            // -1.0, -1.0, 1.0, 1.0, 0.0, 0.0, // v2 Red
            // 1.0, -1.0, 1.0, 1.0, 1.0, 0.0, // v3 Yellow
            // 1.0, -1.0, -1.0, 0.0, 1.0, 0.0, // v4 Green
            // 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, // v5 Cyan
            // -1.0, 1.0, -1.0, 0.0, 0.0, 1.0, // v6 Blue
            // -1.0, -1.0, -1.0, 0.0, 0.0, 0.0 // v7 Black

            // 该例将顶点坐标跟颜色分开存储在不同的缓冲区对象中
            1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, // v0-v1-v2-v3 front
            1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, // v0-v3-v4-v5 right
            1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up
            -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, // v1-v6-v7-v2 left
            -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // v7-v4-v3-v2 down
            1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0 // v4-v7-v6-v5 back
        ]);

        var colors = new Float32Array([
            0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, // v0-v1-v2-v3 front(blue)
            0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, // v0-v3-v4-v5 right(green)
            1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, 1.0, 0.4, 0.4, // v0-v5-v6-v1 up(red)
            1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, // v1-v6-v7-v2 left
            1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, // v7-v4-v3-v2 down
            0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0, 0.4, 1.0, 1.0 // v4-v7-v6-v5 back
        ]);

        // 顶点索引的数组,无符号整型，对应gl.UNSIGNED_BYTE
        var indices = new Uint8Array([
            0, 1, 2, 0, 2, 3, // front
            4, 5, 6, 4, 6, 7, // right
            8, 9, 10, 8, 10, 11, // up
            12, 13, 14, 12, 14, 15, // left
            16, 17, 18, 16, 18, 19, // down
            20, 21, 22, 20, 22, 23 // back
        ]);

        // 【需要先给一个缓冲区对象绑定数据，并将数据传输给顶点着色去的变量以后，再去操作另一个缓冲区对象！！！】
        // 不然两个缓冲区之间会产生冲突！！！
        createArrayBuffer('a_Position', vertices, 3);
        createArrayBuffer('a_Color', colors, 3);

        // 将顶点索引数据写入缓冲区对象
        var indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        // return n;
        // 为什么是返回顶点索引数组的长度，应该是因为在绘制图形时，使用的是drawElements()方法！！！
        return indices.length;
    }

    // 根据不同的顶点信息，创建不同的缓冲区的方法
    function createArrayBuffer(attribute,data,num) {
        var buffer = gl.createBuffer(); // 创建缓冲区
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer); // 将缓冲区绑定为gl.ARRAY_BUFFER类型目标
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); // 将数组中的数据绑定到缓冲区对象中
        var a_attribute = gl.getAttribLocation(gl.program, attribute); // 获取顶点着色器中attribute变量的内存地址
        gl.vertexAttribPointer(a_attribute, num, gl.FLOAT, false, 0, 0); // 将缓冲区对象种的数组，传输gei顶点着色器变量
        gl.enableVertexAttribArray(a_attribute); // 开启顶点着色器attribute变量
    }

</script>
</body>
</html>